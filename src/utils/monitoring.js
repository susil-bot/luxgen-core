const logger = require('./logger'); class MonitoringSystem { constructor() { this.metrics = { requests: { total: 0, byMethod: {}, byRoute: {}, byStatus: {}, responseTimes: [] }, errors: { total: 0, byType: {}, byRoute: {} }, performance: { slowQueries: [], memoryUsage: [], cpuUsage: [] }, cache: { hits: 0, misses: 0, hitRate: 0 }, database: { connections: 0, queries: 0, slowQueries: 0 } }; this.startTime = Date.now(); this.uptime = 0; // Start monitoring intervals this.startMonitoring(); } /** * Start monitoring intervals */ startMonitoring() { // Update uptime every second setInterval(() => { this.uptime = Date.now() - this.startTime; }, 1000); // Log performance metrics every 5 minutes setInterval(() => { this.logPerformanceMetrics(); }, 5 * 60 * 1000); // Log memory usage every minute setInterval(() => { this.recordMemoryUsage(); }, 60 * 1000); // Clean up old metrics every hour setInterval(() => { this.cleanupOldMetrics(); }, 60 * 60 * 1000); } /** * Record HTTP request */ recordRequest(method, route, statusCode, responseTime) { this.metrics.requests.total++; // Record by method this.metrics.requests.byMethod[method] = (this.metrics.requests.byMethod[method] || 0) + 1; // Record by route this.metrics.requests.byRoute[route] = (this.metrics.requests.byRoute[route] || 0) + 1; // Record by status this.metrics.requests.byStatus[statusCode] = (this.metrics.requests.byStatus[statusCode] || 0) + 1; // Record response time this.metrics.requests.responseTimes.push({ timestamp: Date.now(), responseTime, route, method }); // Keep only last 1000 response times if (this.metrics.requests.responseTimes.length > 1000) { this.metrics.requests.responseTimes.shift(); } // Record slow requests (> 1 second) if (responseTime > 1000) { this.metrics.performance.slowQueries.push({ timestamp: Date.now(), route, method, responseTime }); // Keep only last 100 slow queries if (this.metrics.performance.slowQueries.length > 100) { this.metrics.performance.slowQueries.shift(); } } } /** * Record error */ recordError(errorType, route, error) { this.metrics.errors.total++; // Record by type this.metrics.errors.byType[errorType] = (this.metrics.errors.byType[errorType] || 0) + 1; // Record by route this.metrics.errors.byRoute[route] = (this.metrics.errors.byRoute[route] || 0) + 1; logger.error(` Error recorded: ${errorType} on ${route}`, { error: error.message, stack: error.stack, timestamp: new Date().toISOString() }); } /** * Record cache hit/miss */ recordCacheHit(hit) { if (hit) { this.metrics.cache.hits++; } else { this.metrics.cache.misses++; } // Calculate hit rate const total = this.metrics.cache.hits + this.metrics.cache.misses; this.metrics.cache.hitRate = total > 0 ? (this.metrics.cache.hits / total) * 100: 0; } /** * Record database query */ recordDatabaseQuery(query, duration) { this.metrics.database.queries++; // Record slow queries (> 100ms) if (duration > 100) { this.metrics.database.slowQueries++; logger.warn(`🐌 Slow database query detected: ${duration}ms`, { query: query.substring(0, 200) + '...', duration, timestamp: new Date().toISOString() }); } } /** * Record memory usage */ recordMemoryUsage() { const memUsage = process.memoryUsage(); this.metrics.performance.memoryUsage.push({ timestamp: Date.now(), rss: memUsage.rss, heapUsed: memUsage.heapUsed, heapTotal: memUsage.heapTotal, external: memUsage.external }); // Keep only last 100 memory readings if (this.metrics.performance.memoryUsage.length > 100) { this.metrics.performance.memoryUsage.shift(); } // Log high memory usage const heapUsedMB = memUsage.heapUsed / 1024 / 1024; if (heapUsedMB > 500) { // 500MB threshold logger.warn(` WARNING: High memory usage detected: ${heapUsedMB.toFixed(2)}MB`); } } /** * Get current metrics */ getMetrics() { const avgResponseTime = this.metrics.requests.responseTimes.length > 0 ? this.metrics.requests.responseTimes.reduce((sum, rt) => sum + rt.responseTime, 0) / this.metrics.requests.responseTimes.length: 0; const latestMemory = this.metrics.performance.memoryUsage.length > 0 ? this.metrics.performance.memoryUsage[this.metrics.performance.memoryUsage.length - 1]: null; return { uptime: this.uptime, requests: { total: this.metrics.requests.total, byMethod: this.metrics.requests.byMethod, byRoute: this.metrics.requests.byRoute, byStatus: this.metrics.requests.byStatus, averageResponseTime: avgResponseTime }, errors: { total: this.metrics.errors.total, byType: this.metrics.errors.byType, byRoute: this.metrics.errors.byRoute }, cache: { hits: this.metrics.cache.hits, misses: this.metrics.cache.misses, hitRate: this.metrics.cache.hitRate }, database: { queries: this.metrics.database.queries, slowQueries: this.metrics.database.slowQueries, slowQueryRate: this.metrics.database.queries > 0 ? (this.metrics.database.slowQueries / this.metrics.database.queries) * 100: 0 }, performance: { memoryUsage: latestMemory, slowQueries: this.metrics.performance.slowQueries.slice(-10) // Last 10 slow queries }, timestamp: new Date().toISOString() }; } /** * Get health status */ getHealthStatus() { const metrics = this.getMetrics(); const avgResponseTime = metrics.requests.averageResponseTime; const errorRate = metrics.requests.total > 0 ? (metrics.errors.total / metrics.requests.total) * 100: 0; const memoryUsage = metrics.performance.memoryUsage; const health = { status: 'healthy', checks: { responseTime: { status: avgResponseTime < 1000 ? 'healthy': 'warning', value: `${avgResponseTime.toFixed(2)}ms`, threshold: '1000ms'}, errorRate: { status: errorRate < 5 ? 'healthy': 'critical', value: `${errorRate.toFixed(2)}%`, threshold: '5%'}, memoryUsage: { status: memoryUsage && memoryUsage.heapUsed / 1024 / 1024 < 500 ? 'healthy': 'warning', value: memoryUsage ? `${(memoryUsage.heapUsed / 1024 / 1024).toFixed(2)}MB`: 'unknown', threshold: '500MB'}, cacheHitRate: { status: metrics.cache.hitRate > 80 ? 'healthy': 'warning', value: `${metrics.cache.hitRate.toFixed(2)}%`, threshold: '80%'} }, uptime: this.uptime, timestamp: new Date().toISOString() }; // Determine overall status const criticalChecks = Object.values(health.checks).filter(check => check.status === 'critical'); const warningChecks = Object.values(health.checks).filter(check => check.status === 'warning'); if (criticalChecks.length > 0) { health.status = 'critical'; } else if (warningChecks.length > 0) { health.status = 'warning'; } return health; } /** * Log performance metrics */ logPerformanceMetrics() { const metrics = this.getMetrics(); logger.info('Performance Metrics', { uptime: `${Math.floor(metrics.uptime / 1000 / 60)} minutes`, totalRequests: metrics.requests.total, averageResponseTime: `${metrics.requests.averageResponseTime.toFixed(2)}ms`, errorRate: `${((metrics.errors.total / metrics.requests.total) * 100).toFixed(2)}%`, cacheHitRate: `${metrics.cache.hitRate.toFixed(2)}%`, slowQueryRate: `${metrics.database.slowQueryRate.toFixed(2)}%`, memoryUsage: metrics.performance.memoryUsage ? `${(metrics.performance.memoryUsage.heapUsed / 1024 / 1024).toFixed(2)}MB`: 'unknown'}); } /** * Clean up old metrics */ cleanupOldMetrics() { const oneHourAgo = Date.now() - (60 * 60 * 1000); // Clean up old response times this.metrics.requests.responseTimes = this.metrics.requests.responseTimes.filter(rt => rt.timestamp > oneHourAgo); // Clean up old slow queries this.metrics.performance.slowQueries = this.metrics.performance.slowQueries.filter(sq => sq.timestamp > oneHourAgo); // Clean up old memory usage (keep last 24 hours) const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000); this.metrics.performance.memoryUsage = this.metrics.performance.memoryUsage.filter(mu => mu.timestamp > oneDayAgo); logger.debug('Cleaned up old metrics'); } /** * Reset metrics */ resetMetrics() { this.metrics = { requests: { total: 0, byMethod: {}, byRoute: {}, byStatus: {}, responseTimes: [] }, errors: { total: 0, byType: {}, byRoute: {} }, performance: { slowQueries: [], memoryUsage: [], cpuUsage: [] }, cache: { hits: 0, misses: 0, hitRate: 0 }, database: { connections: 0, queries: 0, slowQueries: 0 } }; logger.info('Metrics reset'); }
} // Create singleton instance
const monitoringSystem = new MonitoringSystem(); module.exports = monitoringSystem; 