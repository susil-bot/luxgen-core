const mongoose = require('mongoose'); const notificationSchema = new mongoose.Schema({ // Core notification information tenantId: { type: mongoose.Schema.Types.ObjectId, ref: 'Tenant', required: true, index: true }, userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true }, // Notification content type: { type: String, enum: [ 'poll_created', 'poll_response', 'poll_completed', 'poll_expired', 'user_registered', 'user_invited', 'user_role_changed', 'system_alert', 'security_alert', 'maintenance_notice', 'subscription_expiring', 'subscription_expired', 'usage_limit_warning', 'feedback_received', 'comment_added', 'mention', 'welcome', 'password_reset', 'email_verification', 'custom'], required: true, index: true }, title: { type: String, required: true, trim: true, maxlength: 255 }, message: { type: String, required: true, trim: true }, // Priority and importance priority: { type: String, enum: ['low', 'normal', 'high', 'urgent'], default: 'normal', index: true }, importance: { type: String, enum: ['info', 'success', 'warning', 'error'], default: 'info', index: true }, // Status tracking isRead: { type: Boolean, default: false, index: true }, readAt: { type: Date }, isArchived: { type: Boolean, default: false, index: true }, archivedAt: { type: Date }, // Delivery settings delivery: { channels: [{ type: String, enum: ['in_app', 'email', 'push', 'sms', 'webhook'], default: ['in_app'] }], scheduledAt: Date, sentAt: Date, deliveredAt: Date, failedAt: Date, retryCount: { type: Number, default: 0, min: 0 }, maxRetries: { type: Number, default: 3, min: 0 } }, // Action and navigation action: { type: { type: String, enum: ['navigate', 'open_url', 'api_call', 'dismiss'], default: 'navigate'}, url: String, route: String, params: mongoose.Schema.Types.Mixed, method: { type: String, enum: ['GET', 'POST', 'PUT', 'DELETE'], default: 'GET'} }, // Related resources relatedResource: { type: { type: String, enum: ['poll', 'user', 'tenant', 'session', 'audit_log'], trim: true }, id: { type: mongoose.Schema.Types.ObjectId, sparse: true }, name: String }, // Data payload data: { type: mongoose.Schema.Types.Mixed, default: {} }, // Expiration and cleanup expiresAt: { type: Date, index: true }, autoDelete: { type: Boolean, default: true }, deleteAfterDays: { type: Number, default: 30, min: 1 }, // Grouping and threading groupId: { type: String, sparse: true, index: true }, threadId: { type: String, sparse: true, index: true }, // Metadata metadata: { type: mongoose.Schema.Types.Mixed, default: {} }
}, { timestamps: true, toJSON: { virtuals: true }, toObject: { virtuals: true }
}); // Virtual for is expired
notificationSchema.virtual('isExpired').get(function() { return this.expiresAt && this.expiresAt < new Date();
}); // Virtual for can retry
notificationSchema.virtual('canRetry').get(function() { return this.delivery.retryCount < this.delivery.maxRetries;
}); // Virtual for delivery status
notificationSchema.virtual('deliveryStatus').get(function() { if (this.delivery.failedAt) return 'failed'; if (this.delivery.deliveredAt) return 'delivered'; if (this.delivery.sentAt) return 'sent'; if (this.delivery.scheduledAt) return 'scheduled'; return 'pending';
}); // Indexes for performance
notificationSchema.index({ tenantId: 1, userId: 1, isRead: 1 });
notificationSchema.index({ tenantId: 1, type: 1, createdAt: -1 });
notificationSchema.index({ userId: 1, isRead: 1, createdAt: -1 });
notificationSchema.index({ priority: 1, createdAt: -1 });
notificationSchema.index({ expiresAt: 1 });
notificationSchema.index({ 'delivery.scheduledAt': 1 });
notificationSchema.index({ groupId: 1, createdAt: -1 }); // TTL index for automatic cleanup
notificationSchema.index({ createdAt: 1 }, { expireAfterSeconds: 30 * 24 * 60 * 60, // 30 days default partialFilterExpression: { autoDelete: true }
}); // Pre-save middleware
notificationSchema.pre('save', function(next) { // Auto-set readAt when marked as read if (this.isModified('isRead') && this.isRead && !this.readAt) { this.readAt = new Date(); } // Auto-set archivedAt when marked as archived if (this.isModified('isArchived') && this.isArchived && !this.archivedAt) { this.archivedAt = new Date(); } // Auto-set expiresAt if not provided if (!this.expiresAt && this.autoDelete) { this.expiresAt = new Date(Date.now() + this.deleteAfterDays * 24 * 60 * 60 * 1000); } next();
}); // Instance methods
notificationSchema.methods.markAsRead = async function() { this.isRead = true; this.readAt = new Date(); return this.save();
}; notificationSchema.methods.markAsUnread = async function() { this.isRead = false; this.readAt = null; return this.save();
}; notificationSchema.methods.archive = async function() { this.isArchived = true; this.archivedAt = new Date(); return this.save();
}; notificationSchema.methods.unarchive = async function() { this.isArchived = false; this.archivedAt = null; return this.save();
}; notificationSchema.methods.retryDelivery = async function() { if (this.canRetry) { this.delivery.retryCount += 1; this.delivery.failedAt = null; this.delivery.sentAt = null; this.delivery.deliveredAt = null; return this.save(); } throw new Error('Max retries exceeded');
}; notificationSchema.methods.markAsDelivered = async function() { this.delivery.deliveredAt = new Date(); return this.save();
}; notificationSchema.methods.markAsFailed = async function() { this.delivery.failedAt = new Date(); return this.save();
}; // Static methods
notificationSchema.statics.createNotification = async function(data) { const Notification = mongoose.model('Notification'); const notification = new Notification(data); return notification.save();
}; notificationSchema.statics.findByUser = function(userId, options = {}) { const query = { userId, isArchived: false }; if (options.isRead !== undefined) { query.isRead = options.isRead; } if (options.type) { query.type = options.type; } if (options.priority) { query.priority = options.priority; } return this.find(query).sort({ createdAt: -1 });
}; notificationSchema.statics.findUnreadByUser = function(userId) { return this.find({ userId, isRead: false, isArchived: false }).sort({ createdAt: -1 });
}; notificationSchema.statics.findByTenant = function(tenantId, options = {}) { const query = { tenantId }; if (options.type) { query.type = options.type; } if (options.priority) { query.priority = options.priority; } if (options.isRead !== undefined) { query.isRead = options.isRead; } return this.find(query).sort({ createdAt: -1 });
}; notificationSchema.statics.findPendingDelivery = function() { return this.find({ 'delivery.scheduledAt': { $lte: new Date() }, 'delivery.sentAt': { $exists: false }, 'delivery.failedAt': { $exists: false } });
}; notificationSchema.statics.markAllAsRead = async function(userId) { return this.updateMany( { userId, isRead: false }, { isRead: true, readAt: new Date() } );
}; notificationSchema.statics.getNotificationStatistics = function(tenantId, options = {}) { const matchStage = { tenantId: new mongoose.Types.ObjectId(tenantId) }; if (options.startDate && options.endDate) { matchStage.createdAt = { $gte: new Date(options.startDate), $lte: new Date(options.endDate) }; } return this.aggregate([ { $match: matchStage }, { $group: { _id: null, totalNotifications: { $sum: 1 }, unreadNotifications: { $sum: { $cond: ['$isRead', 0, 1] } }, notificationsByType: { $push: '$type'}, notificationsByPriority: { $push: '$priority'}, averageReadTime: { $avg: { $cond: [ '$readAt', { $subtract: ['$readAt', '$createdAt'] }, null ] } } } }, { $project: { totalNotifications: 1, unreadNotifications: 1, averageReadTime: 1, typeBreakdown: { $reduce: { input: '$notificationsByType', initialValue: {}, in: { $mergeObjects: [ '$$value', { $literal: { '$$this': { $add: [{ $ifNull: ['$$value.$$this', 0] }, 1] } } } ] } } }, priorityBreakdown: { $reduce: { input: '$notificationsByPriority', initialValue: {}, in: { $mergeObjects: [ '$$value', { $literal: { '$$this': { $add: [{ $ifNull: ['$$value.$$this', 0] }, 1] } } } ] } } } } } ]);
}; notificationSchema.statics.cleanupExpired = async function() { return this.deleteMany({ expiresAt: { $lt: new Date() }, autoDelete: true });
}; module.exports = mongoose.model('Notification', notificationSchema); 