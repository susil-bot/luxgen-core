const { MongoClient, ServerApiVersion } = require('mongodb');
const logger = require('../utils/logger'); /** * MongoDB Atlas Configuration * * This module handles the native MongoDB driver connection to MongoDB Atlas. * It provides connection management, health monitoring, and utility functions * for database operations. * * @author LuxGen Team * @version 1.0.0 */ // MongoDB Atlas connection configuration
// Get connection URI from environment variables with fallback for development
const uri = process.env.MONGODB_ATLAS_URI || process.env.MONGODB_URI || (() => { logger.warn('WARNING: No MongoDB URI found in environment variables. Please set MONGODB_ATLAS_URI or MONGODB_URI'); return null;
})(); // Validate URI before creating client
if (!uri) { throw new Error('MongoDB URI is required. Please set MONGODB_ATLAS_URI or MONGODB_URI environment variable.');
} // Create a MongoClient with a MongoClientOptions object to set the Stable API version
const client = new MongoClient(uri, { serverApi: { version: ServerApiVersion.v1, strict: true, deprecationErrors: true, }, // Additional connection options for better reliability maxPoolSize: parseInt(process.env.MONGODB_MAX_POOL_SIZE) || 10, minPoolSize: parseInt(process.env.MONGODB_MIN_POOL_SIZE) || 2, maxIdleTimeMS: parseInt(process.env.MONGODB_MAX_IDLE_TIME) || 30000, serverSelectionTimeoutMS: parseInt(process.env.MONGODB_SERVER_SELECTION_TIMEOUT) || 5000, connectTimeoutMS: parseInt(process.env.MONGODB_CONNECT_TIMEOUT) || 10000, socketTimeoutMS: parseInt(process.env.MONGODB_SOCKET_TIMEOUT) || 45000
}); // Connection state tracking
let isConnected = false;
let connectionPromise = null; /** * Connect to MongoDB using native driver * * Establishes a connection to MongoDB Atlas with retry logic and connection pooling. * Implements singleton pattern to prevent multiple connections and includes * comprehensive error handling and event monitoring. * * @returns {Promise<MongoClient>} Connected MongoDB client instance * @throws {Error} If connection fails after all retry attempts * * @example * ```javascript * const client = await connectToMongoDB(); * const db = client.db('my_database'); * ``` */
async function connectToMongoDB() { // Return existing connection if already connected to prevent multiple connections if (isConnected && client.topology && client.topology.isConnected()) { logger.debug('Using existing MongoDB connection'); return client; } // Return existing connection promise if connection is in progress // This prevents multiple simultaneous connection attempts if (connectionPromise) { logger.debug('Connection already in progress, waiting...'); return connectionPromise; } // Create new connection promise with comprehensive error handling connectionPromise = (async () => { const maxRetries = parseInt(process.env.MONGODB_MAX_RETRIES) || 3; let retryCount = 0; while (retryCount < maxRetries) { try { logger.info(`Connecting to MongoDB Atlas... (attempt ${retryCount + 1}/${maxRetries})`); // Connect the client to the server with timeout await client.connect(); // Send a ping to confirm a successful connection await client.db("admin").command({ ping: 1 }); isConnected = true; logger.info("Successfully connected to MongoDB Atlas!"); // Set up connection event listeners for monitoring setupConnectionEventListeners(); return client; } catch (error) { retryCount++; logger.error(`MongoDB connection attempt ${retryCount} failed:`, error.message); if (retryCount >= maxRetries) { logger.error('Maximum MongoDB connection retries reached'); isConnected = false; connectionPromise = null; throw new Error(`Failed to connect to MongoDB after ${maxRetries} attempts: ${error.message}`); } // Exponential backoff for retries const delay = Math.pow(2, retryCount) * 1000; logger.info(`Waiting ${delay}ms before retry...`); await new Promise(resolve => setTimeout(resolve, delay)); } } })(); return connectionPromise;
} /** * Set up connection event listeners for monitoring and error handling * @private */
function setupConnectionEventListeners() { client.on('error', (error) => { logger.error('MongoDB connection error:', error); isConnected = false; }); client.on('close', () => { logger.warn('MongoDB connection closed'); isConnected = false; }); client.on('reconnect', () => { logger.info('MongoDB reconnected'); isConnected = true; }); client.on('timeout', () => { logger.warn('MongoDB connection timeout'); isConnected = false; });
} /** * Get the MongoDB client instance * @returns {MongoClient} MongoDB client */
function getClient() { if (!isConnected) { throw new Error('MongoDB client is not connected. Call connectToMongoDB() first.'); } return client;
} /** * Get a specific database * @param {string} dbName - Database name * @returns {Db} MongoDB database instance */
function getDatabase(dbName = 'luxgen') { const client = getClient(); return client.db(dbName);
} /** * Get a specific collection * @param {string} collectionName - Collection name * @param {string} dbName - Database name * @returns {Collection} MongoDB collection instance */
function getCollection(collectionName, dbName = 'luxgen') { const db = getDatabase(dbName); return db.collection(collectionName);
} /** * Close the MongoDB connection */
async function closeConnection() { try { if (client && client.topology && client.topology.isConnected()) { await client.close(); isConnected = false; connectionPromise = null; logger.info('MongoDB connection closed successfully'); } } catch (error) { logger.error('Error closing MongoDB connection:', error); }
} /** * Test the MongoDB connection * @returns {Promise<boolean>} Connection status */
async function testConnection() { try { const client = await connectToMongoDB(); await client.db("admin").command({ ping: 1 }); return true; } catch (error) { logger.error('MongoDB connection test failed:', error); return false; }
} /** * Get connection status * @returns {Object} Connection status information */
function getConnectionStatus() { return { isConnected, hasClient: !!client, isClientConnected: client && client.topology && client.topology.isConnected(), connectionState: client ? client.topology?.s?.state: 'unknown'};
} // Graceful shutdown handler
process.on('SIGINT', async () => { logger.info('Received SIGINT, closing MongoDB connection...'); await closeConnection(); process.exit(0);
}); process.on('SIGTERM', async () => { logger.info('Received SIGTERM, closing MongoDB connection...'); await closeConnection(); process.exit(0);
}); module.exports = { connectToMongoDB, getClient, getDatabase, getCollection, closeConnection, testConnection, getConnectionStatus
}; 