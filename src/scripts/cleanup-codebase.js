#!/usr/bin/env node /** * Codebase Cleanup Script * * This script performs comprehensive cleanup of the codebase by: * - Removing hardcoded values * - Adding proper comments and documentation * - Validating environment variables * - Checking for security issues * - Optimizing code structure * * @author LuxGen Team * @version 1.0.0 */ const fs = require('fs');
const path = require('path');
const colors = require('colors'); // Configuration
const CONFIG = { // Directories to scan scanDirs: ['src', 'scripts', 'docs'], // File extensions to process fileExtensions: ['.js', '.ts', '.json', '.md'], // Patterns to check for hardcoded values hardcodedPatterns: [ /password\s*[:=]\s*['"][^'"]+['"]/gi, /secret\s*[:=]\s*['"][^'"]+['"]/gi, /key\s*[:=]\s*['"][^'"]+['"]/gi, /token\s*[:=]\s*['"][^'"]+['"]/gi, /mongodb\+srv:\/\/[^@]+@[^'"]+/gi, /http:\/\/localhost:\d+/gi, /https:\/\/[^'"]*\.com[^'"]*/gi ], // Security patterns to check securityPatterns: [ /console\.log\([^)]*password[^)]*\)/gi, /console\.log\([^)]*secret[^)]*\)/gi, /console\.log\([^)]*token[^)]*\)/gi, /eval\(/gi, /new Function\(/gi, /require\([^)]*\.env[^)]*\)/gi ]
}; // Results tracking
const results = { filesScanned: 0, issuesFound: 0, hardcodedValues: [], securityIssues: [], missingComments: [], suggestions: []
}; /** * Log messages with colors */
function log(message, type = 'info') { const timestamp = new Date().toISOString(); const prefix = type === 'error'? '': type === 'warning'? 'WARNING: ': type === 'success'? '': ''; console.log(`${prefix} [${timestamp}] ${message}`);
} /** * Scan a file for issues */
function scanFile(filePath) { try { const content = fs.readFileSync(filePath, 'utf8'); const relativePath = path.relative(process.cwd(), filePath); results.filesScanned++; // Check for hardcoded values CONFIG.hardcodedPatterns.forEach((pattern, index) => { const matches = content.match(pattern); if (matches) { matches.forEach(match => { results.hardcodedValues.push({ file: relativePath, line: getLineNumber(content, match), match: match, type: 'hardcoded_value'}); results.issuesFound++; }); } }); // Check for security issues CONFIG.securityPatterns.forEach((pattern, index) => { const matches = content.match(pattern); if (matches) { matches.forEach(match => { results.securityIssues.push({ file: relativePath, line: getLineNumber(content, match), match: match, type: 'security_issue'}); results.issuesFound++; }); } }); // Check for missing comments in functions if (filePath.endsWith('.js') || filePath.endsWith('.ts')) { checkMissingComments(content, relativePath); } } catch (error) { log(`Error scanning file ${filePath}: ${error.message}`, 'error'); }
} /** * Get line number for a match */
function getLineNumber(content, match) { const lines = content.split('\n'); for (let i = 0; i < lines.length; i++) { if (lines[i].includes(match)) { return i + 1; } } return 0;
} /** * Check for missing comments in functions */
function checkMissingComments(content, filePath) { const functionRegex = /(?:function\s+\w+|const\s+\w+\s*=\s*(?:async\s+)?\([^)]*\)\s*=>|async\s+function\s+\w+)/g; const commentRegex = /\/\*\*[\s\S]*?\*\//; let match; while ((match = functionRegex.exec(content)) !== null) { const beforeFunction = content.substring(0, match.index); const hasComment = commentRegex.test(beforeFunction); if (!hasComment) { results.missingComments.push({ file: filePath, line: getLineNumber(content, match[0]), function: match[0].substring(0, 50) + '...', type: 'missing_comment'}); results.issuesFound++; } }
} /** * Recursively scan directory */
function scanDirectory(dirPath) { try { const items = fs.readdirSync(dirPath); items.forEach(item => { const fullPath = path.join(dirPath, item); const stat = fs.statSync(fullPath); if (stat.isDirectory()) { // Skip node_modules and other common directories if (!['node_modules', '.git', 'dist', 'build'].includes(item)) { scanDirectory(fullPath); } } else if (stat.isFile()) { const ext = path.extname(item); if (CONFIG.fileExtensions.includes(ext)) { scanFile(fullPath); } } }); } catch (error) { log(`Error scanning directory ${dirPath}: ${error.message}`, 'error'); }
} /** * Generate cleanup suggestions */
function generateSuggestions() { const suggestions = []; // Hardcoded values suggestions if (results.hardcodedValues.length > 0) { suggestions.push({ type: 'hardcoded_values', message: 'Replace hardcoded values with environment variables', count: results.hardcodedValues.length, action: 'Use process.env.VARIABLE_NAME instead of hardcoded strings'}); } // Security issues suggestions if (results.securityIssues.length > 0) { suggestions.push({ type: 'security_issues', message: 'Remove sensitive data from console logs', count: results.securityIssues.length, action: 'Use logger.info() with sanitized data or remove sensitive information'}); } // Missing comments suggestions if (results.missingComments.length > 0) { suggestions.push({ type: 'missing_comments', message: 'Add JSDoc comments to functions', count: results.missingComments.length, action: 'Add comprehensive function documentation'}); } return suggestions;
} /** * Generate cleanup report */
function generateReport() { console.log('\n'+ '='.repeat(80)); console.log('CODEBASE CLEANUP REPORT'.rainbow); console.log('='.repeat(80)); console.log(`\n Summary:`); console.log(` Files Scanned: ${results.filesScanned}`); console.log(` Issues Found: ${results.issuesFound}`); console.log(` Hardcoded Values: ${results.hardcodedValues.length}`); console.log(` Security Issues: ${results.securityIssues.length}`); console.log(` Missing Comments: ${results.missingComments.length}`); // Hardcoded values report if (results.hardcodedValues.length > 0) { console.log('\n Hardcoded Values Found:'.yellow); results.hardcodedValues.forEach((issue, index) => { console.log(` ${index + 1}. ${issue.file}:${issue.line}`); console.log(` Match: ${issue.match.substring(0, 100)}...`); }); } // Security issues report if (results.securityIssues.length > 0) { console.log('\n Security Issues Found:'.red); results.securityIssues.forEach((issue, index) => { console.log(` ${index + 1}. ${issue.file}:${issue.line}`); console.log(` Issue: ${issue.match.substring(0, 100)}...`); }); } // Missing comments report if (results.missingComments.length > 0) { console.log('\n Missing Comments:'.blue); results.missingComments.forEach((issue, index) => { console.log(` ${index + 1}. ${issue.file}:${issue.line}`); console.log(` Function: ${issue.function}`); }); } // Suggestions const suggestions = generateSuggestions(); if (suggestions.length > 0) { console.log('\n Cleanup Suggestions:'.green); suggestions.forEach((suggestion, index) => { console.log(` ${index + 1}. ${suggestion.message}`); console.log(` Count: ${suggestion.count}`); console.log(` Action: ${suggestion.action}`); }); } console.log('\n'+ '='.repeat(80)); if (results.issuesFound === 0) { console.log('No issues found! Your codebase is clean.'.green); } else { console.log(` WARNING: Found ${results.issuesFound} issues that need attention.`.yellow); } console.log('='.repeat(80));
} /** * Main cleanup function */
async function runCleanup() { try { log('Starting codebase cleanup analysis...', 'info'); // Scan all configured directories CONFIG.scanDirs.forEach(dir => { if (fs.existsSync(dir)) { log(` Scanning directory: ${dir}`, 'info'); scanDirectory(dir); } else { log(` WARNING: Directory not found: ${dir}`, 'warning'); } }); // Generate and display report generateReport(); // Save detailed report to file const reportPath = path.join(process.cwd(), 'cleanup-report.json'); fs.writeFileSync(reportPath, JSON.stringify(results, null, 2)); log(` Detailed report saved to: ${reportPath}`, 'success'); log('Codebase cleanup analysis completed!', 'success'); } catch (error) { log(` Cleanup analysis failed: ${error.message}`, 'error'); process.exit(1); }
} // Run cleanup if this script is executed directly
if (require.main === module) { runCleanup();
} module.exports = { runCleanup, scanFile, scanDirectory, generateReport
};
